# Rock Paper Scissors Smartcontract

## Objectives

* Basic syntax for Solidity
   * basic types
   * function declarations and definitions
   * smart-contract structure
   * smart-contract deployment
* Solidity projects
   * Basic structure of Solidity project files as generated by `remix`
   * Basic tools: `remix` and `remix-ide`


# Instructions

## Rock Paper Scissors

* Paper (P) beats Rock (R)
* Rock (R) beats Scissors (S)
* Scissors (S) beats Paper (P)

Write a smart contract in Solidity that implements a simple Rock-Paper-Scissors game. Two participants, anonymously, can engage, and play it. The winner take the stake in the game. The game should be fair, and the contract should not be able to cheat.

The contract should emit events for each game played, and the winner should be able to withdraw the stake. The contract should be able to handle multiple games at the same time. The contract should be able to handle multiple games at the same time.

The contract should have the following functions:
* `play` - to play the game. The function should take a hashed version of the `Vote` (P, R, or S) as a parameter. The function should emit an event with the `msg.sender` and the `Vote` hashed.
* `reveal` - to reveal the vote. The function should take the `Vote` (P, R, or S) as a parameter, and a salt, that was used to salt the vote. The function should emit an event with the `msg.sender` and the `Vote` in plain text version.
* `withdraw` - to withdraw the stake. The function should emit an event with the `msg.sender` and the amount withdrawn. The function should only allow withdrawal, if the game has not ended properly and the winner has been determined. For example because the second player has not revealed his vote.
* Only two players can play the game at the same time. The contract should not allow more than two players to play the game at the same time.
* The contract should not allow the same player to play the game twice at the same time with oneself.
* The contract should enforce timeout to reveal the vote. If the second player does not reveal the vote within a certain time, the first player should be able to withdraw the stake entire stake (for both players).


Considerations:
* Everything, including all method calls into contracts, are public. This means, the `vote` function should only take a hashed version of a `Vote`, that is, `P`, `R`, or `S`.
* Use one of the standard hash functions built-in Solidity to hash the vote. For example: `keccak256(abi.encodePacked(vote, salt))`.
* Make sure a fixed amount of stake is used when players play the game. Enforce the second player to match the first player stake.
* Make sure the contract is fair, and the contract cannot cheat.
* Test it with Remix.
* Check how much gas it costs two players to play the game if no unusual protocol violations happen.
* Handle **ALL** edge cases and possible protocol violations. Spend some of your time in DESIGN stage. Do not jump to coding right away.
* Points: 4 points
